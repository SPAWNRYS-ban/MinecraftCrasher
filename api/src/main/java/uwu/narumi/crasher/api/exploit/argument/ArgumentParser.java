package uwu.narumi.crasher.api.exploit.argument;

import java.util.Arrays;
import uwu.narumi.crasher.api.exception.CommandException;
import uwu.narumi.crasher.api.exploit.Exploit;
import uwu.narumi.crasher.api.helper.AddressHelper;
import uwu.narumi.crasher.api.helper.AddressHelper.McAddress;

public class ArgumentParser {

  /*
  Some shitty usage creator, because im forgetting to update annotation usage xd
   */
  public static String createUsage(Exploit<?> exploit) {
    StringBuilder stringBuilder = new StringBuilder();

    stringBuilder
        .append("crash ")
        .append(exploit.getName())
        .append(" ");

    for (Argument argument : exploit.getArguments()) {
      stringBuilder
          .append("<")
          .append(argument.getName())
          .append(">")
          .append(" ");
    }
    return stringBuilder.toString();
  }

  /*
  Yeah i can make it better but who cares
   */
  public static Object[] parseArgs(Exploit<?> exploit, String[] args) throws CommandException {
    if (exploit.getArguments().length > args.length) {
      throw new CommandException("Usage: " + exploit.getUsage());
    }

    Object[] parsedArgs = new Object[exploit.getArguments().length];
    for (Argument argument : exploit.getArguments()) {
      try {
        String arg = args[argument.getIndex()];
        if (argument.getType() == String[].class) {
          if (argument.getIndex() < (exploit.getArguments().length - 1)) {
            throw new CommandException("Array argument should be last.");
          }

          parsedArgs[argument.getIndex()] = String
              .join(" ", Arrays.copyOfRange(args, argument.getIndex(), args.length));
          break;
        } else if (argument.getType() == Byte[].class) {
          if (argument.getIndex() < (exploit.getArguments().length - 1)) {
            throw new CommandException("Array argument should be last.");
          }

          String[] strings = Arrays.copyOfRange(args, argument.getIndex(), args.length);
          byte[] bytes = new byte[strings.length];
          for (int i = 0; i < strings.length; i++) {
            try {
              bytes[i] = Byte.parseByte(strings[i]);
            } catch (Exception e) {
              throw new CommandException("Can't parse byte");
            }
          }
          parsedArgs[argument.getIndex()] = bytes;
        } else if (argument.getType() == Integer.class || argument.getType() == Character.class
            || argument.getType() == Byte.class) {
          parsedArgs[argument.getIndex()] = Integer.parseInt(arg);
        } else if (argument.getType() == Double.class) {
          parsedArgs[argument.getIndex()] = Double.parseDouble(arg);
        } else if (argument.getType() == Float.class) {
          parsedArgs[argument.getIndex()] = Float.parseFloat(arg);
        } else if (argument.getType() == Long.class) {
          parsedArgs[argument.getIndex()] = Long.parseLong(arg);
        } else if (argument.getType() == String.class) {
          parsedArgs[argument.getIndex()] = arg;
        } else if (argument.getType() == McAddress.class) {
          parsedArgs[argument.getIndex()] = AddressHelper.resolve(arg);
        } else {
          parsedArgs[argument.getIndex()] = Boolean.getBoolean(arg);
        }
      } catch (Exception e) {
        throw new CommandException(
            String.format("Can't parse exploit argument. [Name: %s, Index: %s, Type: %s]",
                argument.getName(), argument.getIndex(), argument.getType().getSimpleName()));
      }
    }
    return parsedArgs;
  }
}
